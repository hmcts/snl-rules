package uk.gov.hmcts.reform.sandl.snlrules.rules

import java.time.OffsetDateTime;
import java.time.ZoneOffset;

import uk.gov.hmcts.reform.sandl.snlrules.model.now.Year;
import uk.gov.hmcts.reform.sandl.snlrules.model.now.Month;
import uk.gov.hmcts.reform.sandl.snlrules.model.now.Day;
import uk.gov.hmcts.reform.sandl.snlrules.model.Problem;
import uk.gov.hmcts.reform.sandl.snlrules.model.ProblemReference;
import uk.gov.hmcts.reform.sandl.snlrules.model.ProblemTypes;
import uk.gov.hmcts.reform.sandl.snlrules.model.ProblemSeverities;
import uk.gov.hmcts.reform.sandl.snlrules.model.Session;
import uk.gov.hmcts.reform.sandl.snlrules.model.Judge;
import uk.gov.hmcts.reform.sandl.snlrules.model.Availability;


rule "Session Time For the Judge not Available"
    when
        $s : Session()
        not Availability(judgeId == $s.judgeId && ($s.start.compareTo(start) >= 0 && $s.end.compareTo(end) <= 0))
    then
        insertLogical(new Problem(ProblemTypes.Session_does_not_have_a_judge_available,
                                  ProblemSeverities.Warn,
                                  new ProblemReference("session", $s.getId()),
                                  new ProblemReference("judge", $s.getJudgeId())));
end

rule "Session does not have a judge 4 weeks or less before start"
    when
        Year($year: year)
        Month($month: month)
        Day($day: day)
        $s : Session(judgeId == null && start.minusDays(29).compareTo(OffsetDateTime.of($year, $month, $day, 0, 0, 0, 0, ZoneOffset.UTC)) < 0)
    then
        insertLogical(new Problem(ProblemTypes.Session_does_not_have_a_judge_4_weeks_or_nearer_before_start,
                                  ProblemSeverities.Warn,
                                  new ProblemReference("session", $s.getId())));
end

rule "Session does not have a room 4 weeks or less before start"
    when
        Year($year: year)
        Month($month: month)
        Day($day: day)
        $s : Session(roomId == null && start.minusDays(29).compareTo(OffsetDateTime.of($year, $month, $day, 0, 0, 0, 0, ZoneOffset.UTC)) < 0)
    then
        insertLogical(new Problem(ProblemTypes.Session_does_not_have_a_room_4_weeks_or_nearer_before_start,
                                  ProblemSeverities.Warn,
                                  new ProblemReference("session", $s.getId())));
end

rule "Double booking of judge (includes any overlapping)"
    when
        $s : Session()
        $s2 : Session(this != $s && judgeId != null && judgeId == $s.judgeId && isOverlapping($s))
    then
        // this if logic here really is to avoid duplication of the problem for those two conflicting sessions
        // this way both rules runs on both session would produce the same problem (rather than two due to how Problem is coded)
        // looks a bit tricky and needs to get reviewed once the new problem model is done
        // and considered whether it should not be covered by equals and hashcode of Problem (not Fact)
        Problem p1 = new Problem(ProblemTypes.Double_booking_of_judge_includes_any_overlapping,
                                  ProblemSeverities.Warn,
                                  new ProblemReference("session", $s.getId()),
                                  new ProblemReference("session", $s2.getId()));
        Problem p2 = new Problem(ProblemTypes.Double_booking_of_judge_includes_any_overlapping,
                                  ProblemSeverities.Warn,
                                  new ProblemReference("session", $s2.getId()),
                                  new ProblemReference("session", $s.getId()));

        if (p1.getId().compareTo(p2.getId()) > 0) {
            insertLogical(p1);
        } else {
            insertLogical(p2);
        }
end


rule "Double booking of room (includes any overlapping)"
    when
        Year($year: year)
        Month($month: month)
        Day($day: day)
        $s : Session()
        $s2 : Session(this != $s && roomId != null && roomId == $s.roomId && isOverlapping($s)
                        && start.minusDays(15).compareTo(OffsetDateTime.of($year, $month, $day, 0, 0, 0, 0, ZoneOffset.UTC)) < 0)
    then
        // this if logic here really is to avoid duplication of the problem for those two conflicting sessions
        // this way both rules runs on both session would produce the same problem (rather than two due to how Problem is coded)
        // looks a bit tricky and needs to get reviewed once the new problem model is done
        // and considered whether it should not be covered by equals and hashcode of Problem (not Fact)
        Problem p1 = new Problem(ProblemTypes.Double_booking_of_room_includes_any_overlapping_2_weeks_or_nearer_before_start,
                                  ProblemSeverities.Warn,
                                  new ProblemReference("session", $s.getId()),
                                  new ProblemReference("session", $s2.getId()));
        Problem p2 = new Problem(ProblemTypes.Double_booking_of_room_includes_any_overlapping_2_weeks_or_nearer_before_start,
                                  ProblemSeverities.Warn,
                                  new ProblemReference("session", $s2.getId()),
                                  new ProblemReference("session", $s.getId()));

        if (p1.getId().compareTo(p2.getId()) > 0) {
            insertLogical(p1);
        } else {
            insertLogical(p2);
        }
end
